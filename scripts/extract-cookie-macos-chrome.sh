#!/usr/bin/env bash
set -euo pipefail

# Best-effort extractor for oauth2-proxy session cookie from Google Chrome on macOS.
# Limitations:
# - Modern Chrome encrypts cookies with a key protected by macOS Keychain (AES-GCM).
# - This script can extract plaintext-only cookies. If encrypted, it will exit with a helpful message.
# - You may need to grant Full Disk Access to your terminal app for Chrome's profile directory.
#
# Usage:
#   scripts/extract-cookie-macos-chrome.sh [cookie_name] [host]
# Defaults:
#   cookie_name = _oauth2_proxy
#   host        = api.localhost (fallback to localhost)
# Output:
#   Writes a Netscape format cookie file path to stdout on success.
#   Exits non-zero on failure with a human-friendly reason.

COOKIE_NAME=${1:-_oauth2_proxy}
HOST=${2:-api.localhost}

log() { echo "[cookie:chrome] $*" >&2; }
err() { echo "[cookie:chrome][ERROR] $*" >&2; exit 1; }

# Resolve Chrome profile Cookies DB
PROFILE_DIR="${HOME}/Library/Application Support/Google/Chrome/Default"
COOKIES_DB="${PROFILE_DIR}/Cookies"

command -v sqlite3 >/dev/null 2>&1 || err "sqlite3 not found. Install via Homebrew: brew install sqlite"

if [[ ! -f "$COOKIES_DB" ]]; then
  err "Cookies DB not found at: $COOKIES_DB. Ensure Chrome Default profile exists and grant Full Disk Access to your terminal."
fi

# Function to try fetch cookie row for a given host
fetch_cookie_row() {
  local host=$1
  sqlite3 -batch -noheader -readonly "$COOKIES_DB" \
    "SELECT host_key, name, path, is_secure, expires_utc, value, length(encrypted_value) FROM cookies \
      WHERE name = '$COOKIE_NAME' AND (host_key = '$host' OR host_key LIKE '.%'||'$host') \
      ORDER BY expires_utc DESC LIMIT 1;" || true
}

row=$(fetch_cookie_row "$HOST")
if [[ -z "$row" ]]; then
  # fallback to localhost	
  if [[ "$HOST" != "localhost" ]]; then
    log "No cookie for $HOST, trying localhost"
    row=$(fetch_cookie_row "localhost")
  fi
fi

if [[ -z "$row" ]]; then
  err "Cookie '$COOKIE_NAME' not found for host '$HOST' (or 'localhost'). Log in at https://localhost/login and retry."
fi

# Parse TSV-like output
# columns: host_key|name|path|is_secure|expires_utc|value|len_encrypted
IFS='|' read -r host_key name path is_secure expires_utc value len_encrypted <<<"$row"

if [[ -z "$value" || "$value" == "" ]]; then
  if [[ "${len_encrypted:-0}" != "0" ]]; then
    err "Cookie is encrypted (Chrome >= 80). Automated decryption requires extra tooling. Copy the cookie manually from DevTools or allow a more capable helper."
  fi
fi

# Normalize booleans
secure_flag=$([[ "$is_secure" == "1" ]] && echo TRUE || echo FALSE)

domain=$host_key
[[ "${domain:0:1}" == "." ]] || domain=".$domain"

# Prepare Netscape cookie file in tmp
outfile="/tmp/ollama_zta_cookie_${COOKIE_NAME}.txt"
{
  echo "# Netscape HTTP Cookie File"
  echo "# This file was generated by extract-cookie-macos-chrome.sh"
  # fields: domain, include_subdomains, path, secure, expiry, name, value
  # expiry: use a far future timestamp if 0
  expiry_ts=$([[ "$expires_utc" =~ ^[0-9]+$ ]] && echo "$expires_utc" || echo "2000000000")
  # Chrome stores epoch in WebKit (1601) microseconds; curl ignores expiry in Netscape file, but keep a placeholder
  echo -e "${domain}\tTRUE\t${path}\t${secure_flag}\t${expiry_ts}\t${name}\t${value}"
} > "$outfile"

chmod 600 "$outfile"
echo "$outfile"
